use crate::deconv::SusieDeconv;
use crate::embed_common::*;
use matrix_util::common_io::*;

use candle_nn::AdamW;
use candle_nn::Optimizer;
use fnv::FnvHashMap as HashMap;
use fnv::FnvHashSet as HashSet;
use indicatif::{ProgressBar, ProgressDrawTarget};
use rand::SeedableRng;

#[derive(Args, Debug)]
pub struct AnnotateTopicArgs {
    #[arg(
        short = 'g',
        long = "gene-dictionary",
        help = "A gene dictionary matrix file (generated by `topic`)",
        long_help = "A gene dictionary matrix file (generated by `topic`)\n\
		      The first column should correspond to features (genes).",
        required = true
    )]
    dict_file: Box<str>,

    #[arg(
        short = 'z',
        long = "latent-topic",
        help = "A latent topic proportion file (generated by `topic`)",
        long_help = "A latent topic proportion file (generated by `topic`)\n\
		      Values should be probabilities (on simplex).\n\
		      The first column should correspond to cell names.",
        required = true
    )]
    latent_file: Box<str>,

    #[arg(
        short = 'm',
        long = "marker-genes",
        help = "A marker feature file",
        long_help = "A marker feature file, e.g., mapping genes to cell types. \n\
		     Each line contains two names: \n\
		     (1) gene and \n\
		     (2) cell type \n\
		     (tab-separated or comma-separated). \n\
		     We allow space but will replace it with '_'.",
        required = true
    )]
    marker_file: Box<str>,

    #[arg(
        long,
        short = 'i',
        default_value_t = 500,
        help = "Number of training epochs."
    )]
    epochs: usize,

    #[arg(
        short = 'c',
        long,
        default_value_t = 1e4,
        help = "Column sum normalization scale.",
        long_help = "Column sum normalization to scale the model parameters."
    )]
    column_sum_norm: f32,

    #[arg(
        short = 'l',
        long,
        default_value_t = 1e-2,
        help = "Learning rate for optimization."
    )]
    learning_rate: f64,

    #[arg(
        long,
        short = 'L',
        default_value_t = 3,
        help = "Number of SuSiE components (L)."
    )]
    susie_components: usize,

    #[arg(
        long,
        short = 's',
        default_value_t = 10,
        help = "Number of Monte Carlo samples for SGVB."
    )]
    num_samples: usize,

    #[arg(
        long,
        default_value_t = 1.0,
        help = "Prior variance for effect sizes."
    )]
    prior_var: f32,

    #[arg(
        long,
        short,
        required = true,
        help = "Output header",
        long_help = "Output header for results.\n\
		     Specify the output file or prefix for generated files."
    )]
    out: Box<str>,

    #[arg(
        long,
        short,
        help = "Verbosity.",
        long_help = "Enable verbose output.\n\
		     Prints additional information during execution."
    )]
    verbose: bool,
}

pub fn annotate_topics(args: &AnnotateTopicArgs) -> anyhow::Result<()> {
    if args.verbose {
        std::env::set_var("RUST_LOG", "info");
    }
    env_logger::init();

    // 1. read dictionary (log-probabilities) and latent states (probabilities)
    let MatWithNames {
        rows: row_names,
        cols: _topics,
        mat: log_dict_dk,
    } = read_mat(&args.dict_file)?;

    info!(
        "Read dictionary {} x {}",
        log_dict_dk.nrows(),
        log_dict_dk.ncols()
    );

    let MatWithNames {
        rows: cell_names,
        cols: topic_names,
        mat: topic_nt_raw,
    } = read_mat(&args.latent_file)?;

    // Convert log-probabilities to probabilities if needed
    let topic_nt = if topic_nt_raw.max() <= 0.0 {
        info!("Detected log-probabilities in latent file, converting to probabilities");
        topic_nt_raw.map(|x| x.exp())
    } else {
        topic_nt_raw
    };

    // 2. read marker gene annotation
    let AnnotInfo {
        membership_ga,
        annot_names,
    } = build_annotation_matrix(&args.marker_file, &row_names)?;

    let nnz_features = (0..membership_ga.nrows())
        .filter(|&i| membership_ga.row(i).iter().any(|&x| x > 0.0))
        .count();

    info!(
        "Found {} cell types matched over {} features",
        annot_names.len(),
        nnz_features
    );

    // 3. Build SuSiE-Poisson deconvolution model
    use rand_distr::{Distribution, Poisson};

    let dev = candle_core::Device::Cpu;
    let parameters = candle_nn::VarMap::new();
    let param_builder =
        candle_nn::VarBuilder::from_varmap(&parameters, candle_core::DType::F32, &dev);

    let x_ga = membership_ga.to_tensor(&dev)?;

    let model = SusieDeconv::new(
        x_ga,
        log_dict_dk.ncols(),
        args.susie_components,
        args.prior_var,
        args.num_samples,
        param_builder,
    )?;

    let mut adam = AdamW::new_lr(parameters.all_vars(), args.learning_rate)?;

    let pb = ProgressBar::new(args.epochs as u64);

    if args.verbose {
        pb.set_draw_target(ProgressDrawTarget::hidden());
    }

    // 4. Training loop
    for epoch in 0..args.epochs {
        // Sample Y[g,t] ~ Poisson(β[g,t] * N)
        let mut rng = rand::rngs::StdRng::seed_from_u64(epoch as u64 + 1);
        // log_dict_dk contains log-probabilities, exp and scale for Poisson rate
        let y_gt = log_dict_dk
            .map(|x| {
                Poisson::new(x.exp() * args.column_sum_norm)
                    .unwrap()
                    .sample(&mut rng)
            })
            .to_tensor(&dev)?;

        let loss = model.loss(&y_gt)?;
        adam.backward_step(&loss)?;
        let loss_val: f32 = loss.to_scalar()?;
        pb.inc(1);

        if args.verbose {
            info!("[{}] loss={:.2}", epoch, loss_val);
        }
    }

    pb.finish_and_clear();

    // 5. Output results
    let pip_file = format!("{}.pip.parquet", args.out);
    let cell_annot_file = format!("{}.annotation.parquet", args.out);

    // Get PIP (Posterior Inclusion Probabilities) - annotation x topic
    let pip = model.pip()?;
    let pip_mat = Mat::from_tensor(&pip)?;
    pip_mat.to_parquet(Some(&annot_names), Some(&topic_names), &pip_file)?;

    // Cell annotation = PIP × topic_proportions, then normalize
    let topic_tn = topic_nt.transpose().sum_to_one_columns();
    let topic_annot = (&pip_mat * topic_tn).sum_to_one_columns().transpose();
    topic_annot.to_parquet(Some(&cell_names), Some(&annot_names), &cell_annot_file)?;

    Ok(())
}

fn read_mat(file_path: &str) -> anyhow::Result<MatWithNames<Mat>> {
    Ok(match file_ext(file_path)?.as_ref() {
        "parquet" => Mat::from_parquet(file_path)?,
        _ => Mat::read_data(file_path, &['\t', ','], None, Some(0), None, None)?,
    })
}

fn read_marker_gene_info(file_path: &str) -> anyhow::Result<HashMap<Box<str>, Box<str>>> {
    let ReadLinesOut { lines, header: _ } =
        read_lines_of_words_delim(&file_path, &['\t', ','], -1)?;

    Ok(lines
        .into_iter()
        .filter_map(|words| {
            if words.len() < 2 {
                None
            } else {
                Some((words[0].clone(), words[1].clone()))
            }
        })
        .collect())
}

fn build_annotation_matrix(
    marker_gene_path: &str,
    row_names: &[Box<str>],
) -> anyhow::Result<AnnotInfo> {
    let gene_to_type = read_marker_gene_info(marker_gene_path)?;

    if gene_to_type.is_empty() {
        return Err(anyhow::anyhow!("empty/invalid marker gene information"));
    }

    let mut row_to_type_vec = vec![];

    for (ri, rn) in row_names.iter().enumerate() {
        let rn_lower = rn.to_lowercase();

        // Check each marker gene
        for (marker_gene, cell_type) in gene_to_type.iter() {
            let marker_lower = marker_gene.to_lowercase();

            // 1. Exact match
            if rn_lower == marker_lower {
                row_to_type_vec.push((ri, cell_type));
                continue;
            }

            // 2. Match at word boundary: row ends with "_MARKER" or "MARKER_"
            let suffix_match = rn_lower.ends_with(&format!("_{}", marker_lower));
            let prefix_match = rn_lower.starts_with(&format!("{}_", marker_lower));

            // 3. Match marker as a complete segment between underscores
            let segment_match = rn_lower.contains(&format!("_{}_", marker_lower));

            if suffix_match || prefix_match || segment_match {
                row_to_type_vec.push((ri, cell_type));
            }
        }
    }

    row_to_type_vec.sort();
    row_to_type_vec.dedup();

    let mut id_to_celltypes: Vec<Box<str>> = row_to_type_vec
        .iter()
        .map(|&(_, t)| t.clone())
        .collect::<HashSet<_>>()
        .into_iter()
        .collect();

    id_to_celltypes.sort();

    let celltype_to_id: HashMap<Box<str>, usize> = id_to_celltypes
        .iter()
        .enumerate()
        .map(|(i, x)| (x.clone(), i))
        .collect();

    let triplets = row_to_type_vec
        .iter()
        .filter_map(|&(r, ct)| {
            if let Some(t) = celltype_to_id.get(ct) {
                Some((r, *t, 1.0))
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    let nrow = row_names.len();
    let ncol = id_to_celltypes.len();

    // gene x annotation group
    let membership_ga = Mat::from_nonzero_triplets(nrow, ncol, &triplets)?;

    // remove potential ' '
    let annot_names = id_to_celltypes
        .into_iter()
        .map(|x| x.replace(" ", "_").into_boxed_str())
        .collect();

    Ok(AnnotInfo {
        membership_ga,
        annot_names,
    })
}

struct AnnotInfo {
    membership_ga: Mat,
    annot_names: Vec<Box<str>>,
}
