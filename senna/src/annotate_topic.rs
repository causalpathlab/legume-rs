use crate::embed_common::*;

use dashmap::DashMap as HashMap;
use matrix_util::common_io::*;
use matrix_util::dmatrix_util::*;

#[derive(Args, Debug)]
pub struct AnnotateTopicArgs {
    /// A gene dictionary matrix file (generated by `topic`) (By
    /// default we assume it's logit-scaled). The first column should
    /// correspond to features (genes).
    #[arg(short = 'g', long = "gene-dictionary", required = true)]
    dict_file: Box<str>,

    /// latent topic proportion file (generated by `topic`)
    /// (By default we assume it's logit-scaled).
    #[arg(short = 'z', long = "latent-topic", required = true)]
    latent_file: Box<str>,

    /// marker feature file, e.g., mapping genes to cell types. Each
    /// line contains two names: gene and cell type (tab-separated or
    /// comma-separated)
    #[arg(short = 'm', long = "marker-genes", required = true)]
    marker_file: Box<str>,

    /// Output header
    #[arg(short, long, required = true)]
    out: Box<str>,

    /// verbosity
    #[arg(long, short)]
    verbose: bool,
}

pub fn annotate_topics(args: &AnnotateTopicArgs) -> anyhow::Result<()> {
    if args.verbose {
        std::env::set_var("RUST_LOG", "info");
    }
    env_logger::init();

    // 1. read dictionary
    let MatWithNames {
        rows: genes,
        cols: topics,
        mat: dict_dk,
    } = read_mat(&args.dict_file)?;

    info!("Read dictionary {} x {}", dict_dk.nrows(), dict_dk.ncols());

    // parse gene names ("{ENSG}_{SYMBOL}")




    // 2. read marker gene annotation



    Ok(())
}

fn read_mat(file_path: &str) -> anyhow::Result<MatWithNames<Mat>> {
    Ok(match extension(file_path)?.as_ref() {
        "parquet" => Mat::from_parquet(file_path)?,
        _ => Mat::read_data(file_path, &['\t', ','], None, Some(0), None, None)?,
    })
}
